#!/usr/bin/guile -s
!#

(use-modules (dolcon ui))
(use-modules (ice-9 pretty-print))

(define sr '())
(define lastsearch 0)
(define info-searcheta 0)
(define info-numavail 0)
(define info-numreal 0)
(define info-numtotal 0)
(define lastparse 0)
(define srchid -1)
(define session '())
(define trans '())
(define dpeers '())
(define lastdl 0)

(define (logf msg)
  (write-line msg (current-output-port))
  (catch 'system-error (lambda ()
			 (fsync (current-output-port)))
	 (lambda (key . err) #f))
  )

(define (make-getopt opts optdesc)
  (let ((arg opts) (curpos 0) (rest '()))
    (lambda ()
      (if (eq? arg '()) rest
	  (let ((ret #f))
	    (while (not ret)
		   (if (= curpos 0)
		       (if (eq? (string-ref (car arg) 0) #\-)
			   (set! curpos 1)
			   (begin
			     (set! rest (append rest (list (car arg))))
			     (set! arg (cdr arg))
			     (if (eq? arg '())
				 (set! ret #t)))))
		   (if (> curpos 0)
		       (if (< curpos (string-length (car arg)))
			   (begin (set! ret (string-ref (car arg) curpos)) (set! curpos (+ curpos 1)))
			   (begin (set! curpos 0) (set! arg (cdr arg)) (if (eq? arg '()) (set! ret #t))))))
	    (if (eq? ret #t) rest
		(let ((opt (string-index optdesc ret)))
		  (if (eq? opt #f) (throw 'illegal-option ret)
		      (if (and (< opt (- (string-length optdesc) 1)) (eq? (string-ref optdesc (+ opt 1)) #\:))
			  (let ((ret
				 (cons ret (let ((optarg
						  (if (< curpos (string-length (car arg)))
						      (substring (car arg) curpos)
						      (begin (set! arg (cdr arg)) (if (eq? arg '()) (throw 'requires-argument ret)) (car arg)))))
					     (set! arg (cdr arg)) optarg))))
			    (set! curpos 0)
			    ret)
			  (list ret))))))))))

(define (ftime)
  (let ((ctime (gettimeofday)))
    (+ (car ctime) (/ (cdr ctime) 1000000))))

(define (wanttosearch)
  (> (- (current-time) lastsearch)
     (if (eq? (cdr (assoc 'search-mode session)) 'wait)
	 7200
	 (if (> (length trans) 0) 300 60)))
  )

(define defspeed '())
(let ((matchlist (list
		  (cons (make-regexp "^[][{}() ]*BBB" regexp/icase) 100000))))
  (set! defspeed
	(lambda (sr)
	  (catch 'ret
		 (lambda ()
		   (for-each (lambda (o)
			       (if (regexp-exec (car o) (cadr (cdr (assoc 'peer sr))))
				   (throw 'ret (cdr o))))
			     matchlist)
		   15000)
		 (lambda (sig ret)
		   ret))
	  )))

(define (sr-less? sr1 sr2)
  (let ((s1 (if (cdr (assoc 'speed sr1)) (cdr (assoc 'speed sr1)) (defspeed sr1)))
	(s2 (if (cdr (assoc 'speed sr2)) (cdr (assoc 'speed sr2)) (defspeed sr2))))
    (if (= s1 s2)
	(< (cdr (assoc 'resptime sr1)) (cdr (assoc 'resptime sr2)))
	(> s1 s2)))
  )

(define (srg-less? g1 g2)
  (or (> (length (cdr g1)) (length (cdr g2)))
      (and (= (length (cdr g1)) (length (cdr g2)))
	   (> (car g1) (car g2))))
  )

(define (gettrbysize size)
  (catch 'ret
	 (lambda ()
	   (for-each (lambda (o)
		       (if (= (cdr (assoc 'size (cdr o))) size)
			   (throw 'ret (cdr o))))
		     trans)
	   #f)
	 (lambda (sig ret)
	   ret))
  )

(define (download sr)
  (let ((resp #f))
    (let ((args (list "download"
		      (car (cdr (assoc 'peer sr)))
		      (cadr (cdr (assoc 'peer sr)))
		      (cdr (assoc 'filename sr))
		      (cdr (assoc 'size sr)))))
      (let ((hash (assoc 'hash sr)))
	(if (and hash (not (equal? (cdr hash) ""))) (set! args (append args (list "hash" (cdr hash))))))
      (let ((tag (assoc 'tag session)))
	(if tag (set! args (append args (list "tag" (cdr tag))))))
      (let ((uarg (assoc 'uarg session)))
	(if uarg (set! args (append args (list "user" (cdr uarg))))))
      (set! resp (apply dc-ecmd-assert 200 args)))
    (let ((id (car (dc-intresp resp))))
      (set! trans
	    (cons (cons id (list (assoc 'size sr)
				 (assoc 'peer sr)
				 (assoc 'filename sr)
				 (assoc 'resptime sr)
				 '(curpos . 0)
				 '(state . wait)
				 '(curspeed . #f)
				 '(lastpos . 0)
				 (cons 'id id)
				 (cons 'lasttime (current-time))
				 (cons 'lastprog (current-time))))
		  trans))
      (logf (string-append "downloading "
			   (cdr (assoc 'filename sr))
			   " from "
			   (cadr (cdr (assoc 'peer sr)))
			   ", "
			   (number->string (cdr (assoc 'size sr)))
			   " bytes (id "
			   (number->string id)
			   ", "
			   (number->string (cdr (assoc 'slots sr)))
			   " slots), timing out in "
			   (number->string (max 10 (* (cdr (assoc 'resptime sr)) 2)))
			   " seconds"))))
  (set! lastdl (current-time))
  )

(define (disablepeer peer)
  (let ((newglist '()) (numrem 0))
    (for-each (lambda (g)
		(let ((newlist '()))
		  (for-each (lambda (o)
			      (if (not (equal? (cdr (assoc 'peer o)) peer))
				  (set! newlist (cons o newlist))
				  (set! numrem (+ numrem 1))))
			    (cdr g))
		  (if (not (eq? newlist '()))
		      (set! newglist (cons (cons (car g) (sort newlist sr-less?)) newglist)))))
	      sr)
    (set! sr (sort newglist srg-less?))
    (logf (string-append "disabled " (cadr peer) " and removed " (number->string numrem) " search results")))
  (let* ((dpa (assoc peer dpeers)) (dp (and (pair? dpa) (cdr dpa))))
    (if dp
	(set-cdr! (assoc 'time dp) (current-time))
	(set! dpeers (cons (cons peer (list (cons 'time (current-time))
					    (cons 'peer peer)))
			   dpeers))))
  )

(define (checktrans)
  (let ((time (current-time)))
    (for-each (lambda (o)
		(if (and (memq (cdr (assoc 'state (cdr o))) '(wait hs))
			 (> (- time (cdr (assoc 'lastprog (cdr o)))) (max 10 (* (cdr (assoc 'resptime (cdr o))) 2))))
		    (begin (logf (string-append "transfer " (number->string (car o)) " timing out"))
			   (dc-ecmd-assert 200 "cancel" (car o))
			   (disablepeer (cdr (assoc 'peer (cdr o))))
			   (set! trans (assq-remove! trans (car o)))
			   (write-info-file)))
		(if (and (eq? (cdr (assoc 'state (cdr o))) 'main)
			 (> (- time (cdr (assoc 'lastprog (cdr o)))) 60))
		    (begin (logf (string-append "transfer " (number->string (car o)) " seems to have stalled"))
			   (dc-ecmd-assert 200 "cancel" (car o))
			   (set! trans (assq-remove! trans (car o)))
			   (write-info-file)))
		(if (and (eq? (cdr (assoc 'state (cdr o))) 'main)
			 (> (- (cdr (assoc 'lastprog (cdr o))) (cdr (assoc 'lasttime (cdr o)))) 20))
		    (begin (set-cdr! (assoc 'curspeed (cdr o))
				     (/ (- (cdr (assoc 'curpos (cdr o))) (cdr (assoc 'lastpos (cdr o))))
					(- (cdr (assoc 'lastprog (cdr o))) (cdr (assoc 'lasttime (cdr o))))))
			   (set-cdr! (assoc 'lastpos (cdr o)) (cdr (assoc 'curpos (cdr o))))
			   (set-cdr! (assoc 'lasttime (cdr o)) (cdr (assoc 'lastprog (cdr o))))
			   (write-info-file))))
		trans))
  )

(define (write-info-file)
  (if (assoc 'info-file session)
      (let ((op (open-output-file (cdr (assoc 'info-file session)))))
	(write (list (cons 'numdl (length trans))
		     (cons 'lastdl lastdl)
		     (cons 'availsr info-numavail)
		     (cons 'realsr info-numreal)
		     (cons 'totalsr info-numtotal)
		     (cons 'lastsrch lastsearch)
		     (cons 'srcheta info-searcheta)
		     (cons 'srchmode (cdr (assoc 'search-mode session))))
	       op)
	(newline op)
	(close-port op))))

(define (parseresults)
  (logf (string-append "entering parseresults with "
		       (number->string
			(apply + (map (lambda (o) (length (cdr o))) sr)))
		       " results in "
		       (number->string (length sr))
		       " sizes"))
  (let ((retval #t) (numreal 0) (numtotal 0) (numavail 0))
    (catch 'ret
	   (lambda ()
	     (and (eq? sr '()) (throw 'ret #f))
	     (let ((numrem 0) (countrem 0) (newglist '()))
	       (for-each (lambda (g)
			   (let ((newlist '()))
			     (for-each (lambda (o)
					 (if (< (- (current-time) (cdr (assoc 'recvtime o))) 300)
					     (set! newlist (cons o newlist))
					     (set! countrem (+ countrem 1))))
				       (cdr g))
			     (if (> (length newlist) 0)
				 (set! newglist (cons (cons (car g) (sort newlist sr-less?)) newglist))
				 (set! numrem (+ numrem 1)))))
			 sr)
	       (set! sr (sort newglist srg-less?))
	       (if (> countrem 0)
		   (logf (string-append "removed " (number->string countrem) " time-outed results and " (number->string numrem) " entire sizes"))))
	     (let ((numrem 0) (newlist '()))
	       (for-each (lambda (o)
			   (if (> (- (current-time) (cdr (assoc 'time o))) 1800)
			       (set! numrem (+ numrem 1))
			       (set! newlist (cons o newlist))))
			 dpeers)
	       (set! dpeers newlist)
	       (logf (string-append "re-enabled " (number->string numrem) " disabled users")))
	     (let ((numrem 0) (countrem 0) (newglist '()))
	       (for-each (lambda (g)
			   (let ((newlist '()))
			     (for-each (lambda (o)
					 (if (not (assoc (cdr (assoc 'peer o)) dpeers))
					     (set! newlist (cons o newlist))
					     (set! countrem (+ countrem 1))))
				       (cdr g))
			     (if (> (length newlist) 0)
				 (set! newglist (cons (cons (car g) (sort newlist sr-less?)) newglist))
				 (set! numrem (+ numrem 1)))))
			 sr)
	       (set! sr (sort newglist srg-less?))
	       (if (> countrem 0)
		   (logf (string-append "removed " (number->string countrem) " results with disabled peers and " (number->string numrem) " entire sizes"))))
	     (and (eq? sr '()) (throw 'ret #f))
	     (set! numtotal (apply + (map (lambda (o) (length (cdr o))) sr)))
	     (let* ((maxsize (apply max (map (lambda (o) (length (cdr o))) sr)))
		    (minsize (/ maxsize 3)))
	       (let ((numrem 0) (countrem 0))
		 (for-each (lambda (o) (if (< (length (cdr o)) minsize)
					   (begin (set! countrem (+ countrem (length (cdr o))))
						  (set! numrem (+ numrem 1)))))
			   sr)
		 (if (> countrem 0)
		     (logf (string-append "will disregard " (number->string countrem) " results from " (number->string numrem) " sizes due to popularity lack")))
		 (set! numreal (- numtotal countrem)))
	       (let ((numrem 0) (numrrem 0))
		 (for-each (lambda (g)
			     (for-each (lambda (o)
					 (if (< (cdr (assoc 'slots o)) 1)
					     (begin (set! numrem (+ numrem 1))
						    (if (>= (length (cdr g)) minsize)
							(set! numrrem (+ numrrem 1))))))
				       (cdr g)))
			   sr)
		 (if (> numrem 0)
		     (logf (string-append (number->string numrem) " results had no slots")))
		 (set! numavail (- numreal numrrem)))
	       (for-each (lambda (g)
			   (if (>= (length (cdr g)) minsize)
			       (catch 'found
				      (lambda ()
					(for-each (lambda (o)
						    (and (> (cdr (assoc 'slots o)) 0)
							 (throw 'found o)))
						  (cdr g)))
				      (lambda (sig sr)
					(let ((tr (gettrbysize (cdr (assoc 'size sr)))))
					  (if (not tr)
					      (if (< (length trans) (cdr (assoc 'maxtrans session)))
						  (download sr))
					      (if (and (cdr (assoc 'curspeed tr))
						       (not (equal? (cdr (assoc 'peer sr)) (cdr (assoc 'peer tr))))
						       (> (- (or (cdr (assoc 'speed sr)) (defspeed sr)) (cdr (assoc 'curspeed tr))) 10000))
						  (begin (logf (string-append "abandoning transfer "
									      (number->string (cdr (assoc 'id tr)))
									      " for possible faster sender"))
							 (dc-ecmd-assert 200 "cancel" (cdr (assoc 'id tr)))
							 (set! trans (assq-remove! trans (cdr (assoc 'id tr))))
							 (download sr)))))))))
			 sr)
	       )
	     )
	   (lambda (sig ret)
	     (set! retval ret)
	     ))
    (set! info-numavail numavail)
    (set! info-numreal numreal)
    (set! info-numtotal numtotal)
    (write-info-file)
    retval)
  )

(define (handlesr filename fnet peer size slots resptime hash)
  (if (eq? (cdr (assoc 'search-mode session)) 'wait)
      (begin (set-cdr! (assoc 'search-mode session) 'normal)
	     (logf "reverting to normal mode")))
  (let ((cl (or (assoc size sr)
		(let ((newp (cons size '()))) (set! sr (append sr (list newp))) newp)))
	(newsr (list
		(cons 'filename filename)
		(cons 'peer (list fnet peer))
		(cons 'size size)
		(cons 'slots slots)
		(cons 'resptime resptime)
		(cons 'speed (getspeed peer))
		(cons 'hash hash)
		(cons 'recvtime (current-time))
		(cons 'dis #f)))
	(newlist '()))
    (for-each (lambda (o) (if (not (and (equal? (cdr (assoc 'filename o)) filename)
					(equal? (cdr (assoc 'peer o)) (list fnet peer))))
			      (set! newlist (cons o newlist))))
	      (cdr cl))
    (set-cdr! cl (sort (cons newsr newlist) sr-less?))
    )
  )

; XXX: Redefine to go through the server, once that is implemented
(define (getspeed username)
  (catch 'system-error
	 (lambda ()
	   (let* ((port (open-input-file (string-append (getenv "HOME") "/dc/users/" username))) (avg 0) (numdls (string->number (read-line port))) (max (string->number (read-line port))) (numents (string->number (read-line port))))
	     (do ((i 0 (+ i 1))) ((= i numents) (close-port port) (/ avg numents)) (set! avg (+ avg (string->number (read-line port)))))
	   ))
	 (lambda args
	   #f
	   )
	 )
  )

(define (validate-session session)
  (catch 'wrong-type-arg
	 (lambda ()
	   (and
	    (assoc 'sexpr session)
	    (assoc 'prio session)
	    (assoc 'maxtrans session)
	    #t
	    )
	   )
	 (lambda (key . args)
	   (display "Session data is not an a-list\n" (current-error-port))
	   #f)
	 )
  )

(define (autodl-main args)
  (let ((dc-server #f) (done #f) (retval 0))
    (let ((getopt (make-getopt (cdr args) "whs:S:e:p:t:a:I:")) (arg #f))
      (do ((arg (getopt) (getopt))) ((not (and (pair? arg) (char? (car arg)))) (set! args arg))
	(cond ((eq? (car arg) #\h)
	       (begin (display "usage: autodl [-s server] -S sessfile\n" (current-error-port))
		      (display "       autodl [-w] [-s server] -e search-expression [-p prio] [-t tag] [-a userarg]\n" (current-error-port))
		      (display "       autodl [-s server]\n" (current-error-port))
		      (display "       autodl -h\n" (current-error-port))
		      (exit 0)))
	      ((eq? (car arg) #\s)
	       (set! dc-server (cdr arg)))
	      ((eq? (car arg) #\S)
	       (let ((port (open-file (cdr arg)))) (set! session (read port)) (close-port port)))
	      ((eq? (car arg) #\p)
	       (let ((c (assoc 'prio session)))
		 (if c (set-cdr! c (cdr arg))
		     (set! session (cons (cons 'prio (cdr arg)) session)))))
	      ((eq? (car arg) #\t)
	       (let ((c (assoc 'tag session)))
		 (if c (set-cdr! c (cdr arg))
		     (set! session (cons (cons 'tag (cdr arg)) session)))))
	      ((eq? (car arg) #\a)
	       (let ((c (assoc 'uarg session)))
		 (if c (set-cdr! c (cdr arg))
		     (set! session (cons (cons 'uarg (cdr arg)) session)))))
	      ((eq? (car arg) #\I)
	       (let ((c (assoc 'info-file session)))
		 (if c (set-cdr! c (cdr arg))
		     (set! session (cons (cons 'info-file (cdr arg)) session)))))
	      ((eq? (car arg) #\e)
	       (set! session (cons (cons 'sexpr (dc-lexsexpr (cdr arg))) session)))
	      ((eq? (car arg) #\w)
	       (set! session (cons '(search-mode . wait) session)))
	      )
	)
      )
    (if (eq? session '()) (begin (if (isatty? (current-input-port)) (display "Enter session data (s-expr):\n" (current-error-port))) (set! session (read))))
    (if (not (assoc 'prio session))
	(set! session (cons '(prio . 10) session)))
    (if (not (assoc 'maxtrans session))
	(set! session (cons '(maxtrans . 1) session)))
    (if (not (assoc 'search-mode session))
	(set! session (cons '(search-mode . normal) session)))
    (if (not (validate-session session)) (begin (display "Invalid session!\n" (current-error-port)) (exit 1)))
    (if (not dc-server) (set! dc-server (getenv "DCSERVER")))
    (if (not dc-server) (set! dc-server "localhost"))
    (catch 'system-error
	   (lambda ()
	     (dc-c&l #t dc-server #t))
	   (lambda (key . args)
	     (logf (string-append "could not connect to server: " (apply format #f (cadr args) (caddr args))))
	     (exit 2)))
    (dc-ecmd-assert 200 "notify" "all" "on")
    (for-each (lambda (sig) (sigaction sig (lambda (sig) (throw 'sig sig)))) (list SIGINT SIGTERM SIGHUP))
    (catch 'sig
	   (lambda ()
	     (while #t
		    (if (and (not (= lastsearch -1)) (wanttosearch))
			(begin
			  (if (not (= srchid -1))
			      (dc-ecmd "cansrch" srchid))
			  (let* ((resp (apply dc-ecmd-assert (append (list '(200 501 509) "search" "prio" (number->string (cdr (assoc 'prio session))) "all") (cdr (assoc 'sexpr session)))))
				 (ires (dc-intresp resp))
				 (eres (dc-extract resp)))
			    (case (cdr (assoc 'code eres))
			      ((200)
			       (begin (set! srchid (car ires))
				      (logf (string-append "search scheduled in " (number->string (cadr ires)) " seconds (id " (number->string srchid) ")"))
				      (set! info-searcheta (+ (current-time) (cadr ires)))
				      (set! lastsearch -1)
				      (write-info-file)))
			      ((501)
			       (begin (set! srchid -1)
				      (logf (string-append "no fnetnodes available to search on"))
				      (set! lastsearch (current-time))))
			      ((509)
			       (begin (logf "illegal search expression")
				      (set! done #t)
				      (set! retval 3)
				      (throw 'sig 0)))))))
		    (checktrans)
		    (if (> (- (current-time) lastparse) 20)
			(begin (parseresults)
			       (set! lastparse (current-time))))
		    (dc-select 10000)
		    (while (let ((resp (dc-getresp)))
			     (if resp
				 (begin
				   (let* ((er (dc-extract resp)) (code (cdr (assoc 'code er))) (cmd (cdr (assoc 'cmd er))))
				     (cond
				       ((equal? cmd ".notify")
					(case code
					  ((611) ; Transfer state change
					   (let ((ires (dc-intresp resp)) (tr #f))
					     (if (and ires (assoc (car ires) trans))
						 (begin (set! tr (cdr (assoc (car ires) trans)))
							(set-cdr! (assoc 'state tr)
								  (cdr (assoc (cadr ires) '((0 . wait) (1 . hs) (2 . main) (3 . done)))))
							(set-cdr! (assoc 'lastprog tr) (current-time))))))
					  ((614) ; Transfer error
					   (let ((ires (dc-intresp resp)))
					     (if (and ires (assoc (car ires) trans))
						 (begin (logf (string-append "transfer " (number->string (car ires)) " encountered error " (number->string (cadr ires))))
							(dc-ecmd-assert 200 "cancel" (car ires))
							(let ((tr (cdr (assoc (car ires) trans))))
							  (disablepeer (cdr (assoc 'peer tr))))
							(set! trans (assq-remove! trans (car ires)))))))
					  ((615) ; Transfer progress
					   (let ((ires (dc-intresp resp)) (tr #f))
					     (if (and ires (assoc (car ires) trans))
						 (begin (set! tr (cdr (assoc (car ires) trans)))
							(set-cdr! (assoc 'curpos tr) (cadr ires))
							(set-cdr! (assoc 'lastprog tr) (current-time))))))
					  ((617) ; Transfer destroyed
					   (let* ((ires (dc-intresp resp)) (tr (and ires (assoc (car ires) trans))))
					     (if tr
						 (begin (if (eq? (cdr (assoc 'state (cdr tr))) 'done)
							    (begin (logf (string-append "transfer " (number->string (car ires)) " done"))
								   (set! trans (assq-remove! trans (car ires)))
								   (set! done #t)
								   (throw 'sig 0))
							    (begin (logf (string-append "transfer " (number->string (car ires)) " disappeared"))
								   (set! trans (assq-remove! trans (car ires)))))))))
					  ((620) ; Search rescheduled
					   (let ((ires (dc-intresp resp)))
					     (if (and ires (= (car ires) srchid))
						 (begin (set! info-searcheta (+ (current-time) (cadr ires)))
							(logf (string-append "search rescheduled to T+" (number->string (cadr ires))))
							(write-info-file)))))
					  ((621) ; Search committed
					   (let ((ires (dc-intresp resp)))
					     (if (and ires (= (car ires) srchid))
						 (begin (logf "search committed")
							(set! info-searcheta 0)
							(set! lastsearch (current-time))
							(write-info-file)))))
					  ((622) ; Search result
					   (let ((ires (list->vector (dc-intresp resp))))
					     (if (and ires (= (vector-ref ires 0) srchid)) (apply handlesr (map (lambda (n) (vector-ref ires n)) '(1 2 3 4 5 7 8))))))
					  
					  )
					)
				       
				       )
				     )
				   #t)
				 #f)
			     )
			   #t
			   )
		    )
	     )
	   (lambda (key sig)
	     (logf (string-append "interrupted by signal " (number->string sig)))
	     (if (not done)
		 (set! retval 1)))
	   )
    (logf "quitting...")
    (catch 'sig
	   (lambda ()
	     (if (dc-connected)
		 (begin (for-each (lambda (o)
				    (dc-qcmd (list "cancel" (car o))))
				  trans)
			(if (assoc 'info-file session)
			    (catch 'system-error
				   (lambda ()
				     (delete-file (cdr (assoc 'info-file session))))
				   (lambda (key . args) #t)))
			(if (and done (assoc 'tag session))
			    (dc-qcmd (list "filtercmd" "rmtag" (cdr (assoc 'tag session)))))
			(if (not (= srchid -1))
			    (dc-qcmd (list "cansrch" srchid)))
			(dc-qcmd '("quit"))
			(while (dc-connected) (dc-select))
			)))
	   (lambda (key sig)
	     (logf "forcing quit")))
    (exit retval)
    )
  )

(setlocale LC_ALL "")
(autodl-main (command-line))
